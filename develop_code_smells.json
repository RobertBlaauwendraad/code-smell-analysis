[{"id": "14409", "smell": "blob", "severity": "major", "type": "class", "snippet": "public class AsyncRcvdMsgCheckpointImpl<M extends Writable> implements\n    BSPFaultTolerantService<M> {\n\n  private static final Log LOG = LogFactory\n      .getLog(AsyncRcvdMsgCheckpointImpl.class);\n\n  /**\n   * It is responsible to find the smallest superstep for which the\n   * checkpointing is done and then restart all the peers from that superstep.\n   */\n  private static class CheckpointMasterService implements\n      FaultTolerantMasterService {\n\n    private Configuration conf;\n    private TaskInProgress tasks[];\n    private BSPJobID jobId;\n    private int maxTaskAttempts;\n    private int currentAttemptId;\n    private MasterSyncClient masterSyncClient;\n    private TaskAllocationStrategy allocationStrategy;\n\n    /**\n     * Initializes the fault tolerance service at BSPMasters\n     * \n     * @param jobId The identifier of the job.\n     * @param maxTaskAttempts Number of attempts allowed for recovering from\n     *          failure.\n     * @param tasks The list of tasks in the job.\n     * @param conf The job configuration object.\n     * @param masterClient The synchronization client used by BSPMaster.\n     * @param allocationStrategy The task allocation strategy of the job.\n     */\n    public void initialize(BSPJobID jobId, int maxTaskAttempts,\n        TaskInProgress[] tasks, Configuration conf,\n        MasterSyncClient masterClient, TaskAllocationStrategy allocationStrategy) {\n      this.tasks = tasks;\n      this.jobId = jobId;\n      this.conf = conf;\n      this.maxTaskAttempts = maxTaskAttempts;\n      this.currentAttemptId = 0;\n      this.masterSyncClient = masterClient;\n      this.allocationStrategy = allocationStrategy;\n    }\n\n    @Override\n    public boolean isRecoveryPossible(TaskInProgress tip) {\n      return currentAttemptId < maxTaskAttempts;\n    }\n\n    @Override\n    public boolean isAlreadyRecovered(TaskInProgress tip) {\n      return currentAttemptId < tip.getCurrentTaskAttemptId().getId();\n    }\n\n    @Override\n    public void recoverTasks(JobInProgress jip,\n        Map<String, GroomServerStatus> groomStatuses,\n        TaskInProgress[] failedTasksInProgress,\n        TaskInProgress[] allTasksInProgress,\n        Map<GroomServerStatus, Integer> taskCountInGroomMap,\n        Map<GroomServerStatus, List<GroomServerAction>> actionMap)\n        throws IOException {\n\n      Map<TaskID, TaskInProgress> recoverySet = new HashMap<TaskID, TaskInProgress>(\n          2 * failedTasksInProgress.length);\n      for (TaskInProgress failedTasksInProgres : failedTasksInProgress) {\n        recoverySet.put(failedTasksInProgres.getTaskId(), failedTasksInProgres);\n      }\n\n      long lowestSuperstepNumber = Long.MAX_VALUE;\n\n      String[] taskProgress = this.masterSyncClient.getChildKeySet(\n          this.masterSyncClient.constructKey(jobId, \"checkpoint\"), null);\n\n      if (LOG.isDebugEnabled()) {\n        StringBuffer list = new StringBuffer(25 * taskProgress.length);\n        list.append(\"got child key set\").append(taskProgress.length)\n            .append(\"/\").append(tasks.length).append(\" \");\n        for (String entry : taskProgress) {\n          list.append(entry).append(\",\");\n        }\n        LOG.debug(list);\n      }\n\n      if (taskProgress.length == this.tasks.length) {\n        for (String taskProgres : taskProgress) {\n          ArrayWritable progressInformation = new ArrayWritable(\n              LongWritable.class);\n          boolean result = this.masterSyncClient.getInformation(\n              this.masterSyncClient.constructKey(jobId, \"checkpoint\",\n                  taskProgres), progressInformation);\n\n          if (!result) {\n            lowestSuperstepNumber = -1L;\n            break;\n          }\n\n          Writable[] progressArr = progressInformation.get();\n          LongWritable superstepProgress = (LongWritable) progressArr[0];\n\n          if (superstepProgress != null) {\n            if (superstepProgress.get() < lowestSuperstepNumber) {\n              lowestSuperstepNumber = superstepProgress.get();\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Got superstep number \" + lowestSuperstepNumber\n                    + \" from \" + taskProgres);\n              }\n            }\n          }\n        }\n        clearClientForSuperstep(lowestSuperstepNumber);\n        restartJob(lowestSuperstepNumber, groomStatuses, recoverySet,\n            allTasksInProgress, taskCountInGroomMap, actionMap);\n\n      } else {\n        restartJob(-1, groomStatuses, recoverySet, allTasksInProgress,\n            taskCountInGroomMap, actionMap);\n      }\n\n      ++currentAttemptId;\n    }\n\n    private void clearClientForSuperstep(long superstep) {\n      this.masterSyncClient.remove(\n          masterSyncClient.constructKey(jobId, \"sync\"), null);\n    }\n\n    private void populateAction(Task task, long superstep,\n        GroomServerStatus groomStatus,\n        Map<GroomServerStatus, List<GroomServerAction>> actionMap) {\n      List<GroomServerAction> list = actionMap.get(groomStatus);\n      if (!actionMap.containsKey(groomStatus)) {\n        list = new ArrayList<GroomServerAction>();\n        actionMap.put(groomStatus, list);\n      }\n      list.add(new RecoverTaskAction(task, superstep));\n\n    }\n\n    private void restartTask(TaskInProgress tip, long superstep,\n        Map<String, GroomServerStatus> groomStatuses,\n        Map<GroomServerStatus, List<GroomServerAction>> actionMap) {\n      GroomServerStatus serverStatus = tip.getGroomServerStatus();\n      Task task = tip.constructTask(serverStatus);\n      populateAction(task, superstep, serverStatus, actionMap);\n\n    }\n\n    private void restartJob(long superstep,\n        Map<String, GroomServerStatus> groomStatuses,\n        Map<TaskID, TaskInProgress> recoveryMap, TaskInProgress[] allTasks,\n        Map<GroomServerStatus, Integer> taskCountInGroomMap,\n        Map<GroomServerStatus, List<GroomServerAction>> actionMap)\n        throws IOException {\n      String path = conf.get(\"bsp.checkpoint.prefix_path\", \"/checkpoint/\");\n\n      if (superstep >= 0) {\n        FileSystem fileSystem = FileSystem.get(conf);\n        for (TaskInProgress allTask : allTasks) {\n          String[] hosts = null;\n          if (recoveryMap.containsKey(allTask.getTaskId())) {\n\n            // Update task count in map.\n            // TODO: This should be a responsibility of GroomServerStatus\n            Integer count = taskCountInGroomMap.get(allTask\n                .getGroomServerStatus());\n            if (count != null) {\n              count = count.intValue() - 1;\n              taskCountInGroomMap.put(allTask.getGroomServerStatus(), count);\n            }\n\n            StringBuffer ckptPath = new StringBuffer(path);\n            ckptPath.append(this.jobId.toString());\n            ckptPath.append(\"/\").append(superstep).append(\"/\")\n                .append(allTask.getTaskId().getId());\n            Path checkpointPath = new Path(ckptPath.toString());\n            if (fileSystem.exists(checkpointPath)) {\n              FileStatus fileStatus = fileSystem.getFileStatus(checkpointPath);\n              BlockLocation[] blocks = fileSystem.getFileBlockLocations(\n                  fileStatus, 0, fileStatus.getLen());\n              hosts = blocks[0].getHosts();\n            } else {\n              hosts = new String[groomStatuses.keySet().size()];\n              groomStatuses.keySet().toArray(hosts);\n            }\n            GroomServerStatus serverStatus = this.allocationStrategy\n                .getGroomToAllocate(groomStatuses, hosts, taskCountInGroomMap,\n                    new BSPResource[0], allTask);\n            Task task = allTask.constructTask(serverStatus);\n            populateAction(task, superstep, serverStatus, actionMap);\n\n          } else {\n            restartTask(allTask, superstep, groomStatuses, actionMap);\n          }\n        }\n      } else {\n        // Start the task from the beginning.\n        for (TaskInProgress allTask : allTasks) {\n          if (recoveryMap.containsKey(allTask.getTaskId())) {\n            this.allocationStrategy.getGroomToAllocate(groomStatuses,\n                this.allocationStrategy.selectGrooms(groomStatuses,\n                    taskCountInGroomMap, new BSPResource[0], allTask),\n                taskCountInGroomMap, new BSPResource[0], allTask);\n          } else {\n            restartTask(allTask, superstep, groomStatuses, actionMap);\n          }\n        }\n      }\n    }\n\n  }// end of CheckpointMasterService\n\n  @Override\n  public FaultTolerantPeerService<M> constructPeerFaultTolerance(BSPJob job,\n      @SuppressWarnings(\"rawtypes\") BSPPeer bspPeer, PeerSyncClient syncClient,\n      InetSocketAddress peerAddress, TaskAttemptID taskAttemptId,\n      long superstep, Configuration conf, MessageManager<M> messenger)\n      throws Exception {\n    CheckpointPeerService<M> service = new CheckpointPeerService<M>();\n    service.initialize(job, bspPeer, syncClient, peerAddress, taskAttemptId,\n        superstep, conf, messenger);\n    return service;\n  }\n\n  @Override\n  public FaultTolerantMasterService constructMasterFaultTolerance(\n      BSPJobID jobId, int maxTaskAttempts, TaskInProgress[] tasks,\n      Configuration conf, MasterSyncClient masterClient,\n      TaskAllocationStrategy allocationStrategy) throws Exception {\n    CheckpointMasterService service = new CheckpointMasterService();\n    service.initialize(jobId, maxTaskAttempts, tasks, conf, masterClient,\n        allocationStrategy);\n    return service;\n  }\n\n  /**\n   * Initializes the peer fault tolerance by checkpointing service. For\n   * recovery, on peer initialization, it reads all the checkpointed messages to\n   * recover the state of the peer. During normal working, it checkpoints all\n   * the messages it received in the previous superstep. It also stores the\n   * superstep progress in the global synchronization area.\n   * \n   */\n  public static class CheckpointPeerService<M extends Writable> implements\n      FaultTolerantPeerService<M>, MessageEventListener<M> {\n\n    private BSPJob job;\n    @SuppressWarnings(\"rawtypes\")\n    private BSPPeer peer;\n    private PeerSyncClient syncClient;\n    private long superstep;\n    private Configuration conf;\n    private MessageManager<M> messenger;\n    private FileSystem fs;\n    private int checkPointInterval;\n    volatile private long lastCheckPointStep;\n    volatile private boolean checkpointState;\n    volatile private FSDataOutputStream checkpointStream;\n    volatile private long checkpointMessageCount;\n\n    public void initialize(BSPJob job,\n        @SuppressWarnings(\"rawtypes\") BSPPeer bspPeer,\n        PeerSyncClient syncClient, InetSocketAddress peerAddress,\n        TaskAttemptID taskAttemptId, long superstep, Configuration conf,\n        MessageManager<M> messenger) throws IOException {\n\n      this.job = job;\n      this.peer = bspPeer;\n      this.syncClient = syncClient;\n      this.superstep = superstep;\n      this.conf = conf;\n      this.messenger = messenger;\n      this.fs = FileSystem.get(conf);\n      this.checkPointInterval = conf.getInt(Constants.CHECKPOINT_INTERVAL,\n          Constants.DEFAULT_CHECKPOINT_INTERVAL);\n      this.checkPointInterval = conf.getInt(Constants.CHECKPOINT_INTERVAL,\n          Constants.DEFAULT_CHECKPOINT_INTERVAL);\n\n      this.checkpointState = conf.getBoolean(Constants.CHECKPOINT_ENABLED,\n          false);\n\n      if (superstep > 0) {\n        this.lastCheckPointStep = this.superstep;\n      } else {\n        this.lastCheckPointStep = 1;\n      }\n      this.checkpointMessageCount = 0L;\n    }\n\n    private String checkpointPath(long step) {\n      String backup = conf.get(\"bsp.checkpoint.prefix_path\", \"checkpoint/\");\n      String ckptPath = backup + job.getJobID().toString() + \"/\" + (step) + \"/\"\n          + peer.getPeerIndex();\n      if (LOG.isDebugEnabled())\n        LOG.debug(\"Received Messages are to be saved to \" + ckptPath);\n      return ckptPath;\n    }\n\n    @Override\n    public TaskStatus.State onPeerInitialized(TaskStatus.State state)\n        throws Exception {\n      if (this.superstep >= 0 && state.equals(TaskStatus.State.RECOVERING)) {\n        ArrayWritable progressArr = new ArrayWritable(LongWritable.class);\n        boolean result = this.syncClient.getInformation(\n            this.syncClient.constructKey(job.getJobID(), \"checkpoint\",\n                String.valueOf(peer.getPeerIndex())), progressArr);\n\n        if (!result) {\n          throw new IOException(\"No data found to restore peer state.\");\n        }\n\n        Writable[] progressInfo = progressArr.get();\n        long superstepProgress = ((LongWritable) progressInfo[0]).get();\n        long numMessages = ((LongWritable) progressInfo[1]).get();\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Got sstep =\" + superstepProgress + \" numMessages = \"\n              + numMessages + \" this.superstep = \" + this.superstep);\n        }\n\n        if (numMessages > 0) {\n          Path path = new Path(checkpointPath(superstepProgress));\n          FSDataInputStream in = this.fs.open(path);\n          BSPMessageBundle<M> bundle = new BSPMessageBundle<M>();\n\n          try {\n            for (int i = 0; i < numMessages; ++i) {\n              String className = in.readUTF();\n              if (className.equals(BSPMessageBundle.class.getCanonicalName())) {\n                BSPMessageBundle<M> tmp = new BSPMessageBundle<M>();\n                tmp.readFields(in);\n                messenger.loopBackBundle(tmp);\n              } else {\n                @SuppressWarnings(\"unchecked\")\n                M message = (M) ReflectionUtils.newInstance(\n                    Class.forName(className), conf);\n                message.readFields(in);\n                bundle.addMessage(message);\n              }\n            }\n\n            if (bundle.size() > 0) {\n              messenger.loopBackBundle(bundle);\n            }\n          } catch (EOFException e) {\n            LOG.error(\"Error recovering from checkpointing\", e);\n            throw new IOException(e);\n          } finally {\n            this.fs.close();\n          }\n        }\n      }\n      this.messenger.registerListener(this);\n      return TaskStatus.State.RUNNING;\n\n    }\n\n    public final boolean isReadyToCheckpoint() {\n\n      checkPointInterval = conf.getInt(Constants.CHECKPOINT_INTERVAL, 1);\n      LOG.info(new StringBuffer(1000).append(\"Enabled = \")\n          .append(conf.getBoolean(Constants.CHECKPOINT_ENABLED, false))\n          .append(\" checkPointInterval = \").append(checkPointInterval)\n          .append(\" lastCheckPointStep = \").append(lastCheckPointStep)\n          .append(\" getSuperstepCount() = \").append(peer.getSuperstepCount())\n          .toString());\n      if (LOG.isDebugEnabled())\n        LOG.debug(new StringBuffer(1000).append(\"Enabled = \")\n            .append(conf.getBoolean(Constants.CHECKPOINT_ENABLED, false))\n            .append(\" checkPointInterval = \").append(checkPointInterval)\n            .append(\" lastCheckPointStep = \").append(lastCheckPointStep)\n            .append(\" getSuperstepCount() = \").append(peer.getSuperstepCount())\n            .toString());\n\n      return (conf.getBoolean(Constants.CHECKPOINT_ENABLED, false)\n          && (checkPointInterval != 0) && (((int) ((peer.getSuperstepCount() + 1) - lastCheckPointStep)) >= checkPointInterval));\n\n    }\n\n    @Override\n    public void beforeBarrier() throws Exception {\n    }\n\n    @Override\n    public void duringBarrier() throws Exception {\n    }\n\n    @Override\n    public void afterBarrier() throws Exception {\n\n      synchronized (this) {\n        if (checkpointState) {\n\n          if (checkpointStream != null) {\n            this.checkpointStream.close();\n            this.checkpointStream = null;\n          }\n\n          lastCheckPointStep = peer.getSuperstepCount();\n\n          ArrayWritable writableArray = new ArrayWritable(LongWritable.class);\n          Writable[] writeArr = new Writable[2];\n          writeArr[0] = new LongWritable(lastCheckPointStep);\n          writeArr[1] = new LongWritable(checkpointMessageCount);\n          writableArray.set(writeArr);\n\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Storing lastCheckPointStep = \" + lastCheckPointStep\n                + \" checkpointMessageCount = \" + checkpointMessageCount\n                + \" for peer = \" + String.valueOf(peer.getPeerIndex()));\n          }\n\n          this.syncClient.storeInformation(this.syncClient.constructKey(\n              this.job.getJobID(), \"checkpoint\",\n              String.valueOf(peer.getPeerIndex())), writableArray, true, null);\n        }\n        checkpointState = isReadyToCheckpoint();\n        checkpointMessageCount = 0;\n      }\n\n      LOG.info(\"checkpointNext = \" + checkpointState\n          + \" checkpointMessageCount = \" + checkpointMessageCount);\n    }\n\n    @Override\n    public void onInitialized() {\n\n    }\n\n    @Override\n    public void onMessageSent(String peerName, M message) {\n    }\n\n    @Override\n    public void onMessageReceived(M message) {\n      String checkpointedPath = null;\n\n      if (message == null) {\n        LOG.error(\"Message M is found to be null\");\n      }\n\n      synchronized (this) {\n        if (checkpointState) {\n          if (this.checkpointStream == null) {\n            checkpointedPath = checkpointPath(peer.getSuperstepCount() + 1);\n            try {\n              LOG.info(\"Creating path \" + checkpointedPath);\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Creating path \" + checkpointedPath);\n              }\n              checkpointStream = this.fs.create(new Path(checkpointedPath));\n            } catch (IOException ioe) {\n              LOG.error(\"Fail checkpointing messages to \" + checkpointedPath,\n                  ioe);\n              throw new RuntimeException(\"Failed opening HDFS file \"\n                  + checkpointedPath, ioe);\n            }\n          }\n          \n          try {\n            ++checkpointMessageCount;\n            checkpointStream.writeUTF(message.getClass().getCanonicalName());\n            message.write(checkpointStream);\n          } catch (IOException ioe) {\n            LOG.error(\"Fail checkpointing messages to \" + checkpointedPath, ioe);\n            throw new RuntimeException(\"Failed writing to HDFS file \"\n                + checkpointedPath, ioe);\n          }\n\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"message count = \" + checkpointMessageCount);\n          }\n        }\n      }\n\n    }\n\n    @Override\n    public void onClose() {\n\n    }\n\n    @Override\n    public void onBundleReceived(BSPMessageBundle<M> bundle) {\n      String checkpointedPath = null;\n\n      if (bundle == null) {\n        LOG.error(\"bundle is found to be null\");\n      }\n\n      synchronized (this) {\n        if (checkpointState) {\n          if (this.checkpointStream == null) {\n            checkpointedPath = checkpointPath(peer.getSuperstepCount() + 1);\n            try {\n              LOG.info(\"Creating path \" + checkpointedPath);\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Creating path \" + checkpointedPath);\n              }\n              checkpointStream = this.fs.create(new Path(checkpointedPath));\n            } catch (IOException ioe) {\n              LOG.error(\"Fail checkpointing messages to \" + checkpointedPath,\n                  ioe);\n              throw new RuntimeException(\"Failed opening HDFS file \"\n                  + checkpointedPath, ioe);\n            }\n          }\n\n          try {\n            ++checkpointMessageCount;\n            checkpointStream.writeUTF(bundle.getClass().getCanonicalName());\n            bundle.write(checkpointStream);\n          } catch (IOException ioe) {\n            LOG.error(\"Fail checkpointing messages to \" + checkpointedPath, ioe);\n            throw new RuntimeException(\"Failed writing to HDFS file \"\n                + checkpointedPath, ioe);\n          }\n\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"message count = \" + checkpointMessageCount);\n          }\n        }\n      }\n    }\n\n  }\n\n}"}, {"id": "14576", "smell": "data class", "severity": "critical", "type": "class", "snippet": "public class ReportInstance extends AbstractDTOBase {\n\n    private String id;\n    private ReportStatusEnum status;\n    private String url;\n    private String ownerId;\n    private Boolean hasDetailRows;\n    private ZonedDateTime completionDate;\n    private ZonedDateTime requestDate;\n\n    public String getId() {\n        return id;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public ReportStatusEnum getStatus() {\n        return status;\n    }\n\n    public void setStatus(ReportStatusEnum status) {\n        this.status = status;\n    }\n\n    public String getUrl() {\n        return url;\n    }\n\n    public void setUrl(String url) {\n        this.url = url;\n    }\n\n    public String getOwnerId() {\n        return ownerId;\n    }\n\n    public void setOwnerId(String ownerId) {\n        this.ownerId = ownerId;\n    }\n\n    public Boolean getHasDetailRows() {\n        return hasDetailRows;\n    }\n\n    public void setHasDetailRows(Boolean hasDetailRows) {\n        this.hasDetailRows = hasDetailRows;\n    }\n\n    public ZonedDateTime getCompletionDate() {\n        return completionDate;\n    }\n\n    public void setCompletionDate(ZonedDateTime completionDate) {\n        this.completionDate = completionDate;\n    }\n\n    public ZonedDateTime getRequestDate() {\n        return requestDate;\n    }\n\n    public void setRequestDate(ZonedDateTime requestDate) {\n        this.requestDate = requestDate;\n    }\n}"}, {"id": "14666", "smell": "long method", "severity": "critical", "type": "function", "snippet": "    public void validateDepositDetailForUpdate(final JsonElement element, final FromJsonHelper fromApiJsonHelper,\n            final DataValidatorBuilder baseDataValidator) {\n        if (fromApiJsonHelper.parameterExists(nameParamName, element)) {\n            final String name = fromApiJsonHelper.extractStringNamed(nameParamName, element);\n            baseDataValidator.reset().parameter(nameParamName).value(name).notBlank().notExceedingLengthOf(100);\n        }\n\n        if (fromApiJsonHelper.parameterExists(shortNameParamName, element)) {\n            final String shortName = fromApiJsonHelper.extractStringNamed(shortNameParamName, element);\n            baseDataValidator.reset().parameter(shortNameParamName).value(shortName).notBlank().notExceedingLengthOf(4);\n        }\n\n        if (fromApiJsonHelper.parameterExists(descriptionParamName, element)) {\n            final String description = fromApiJsonHelper.extractStringNamed(descriptionParamName, element);\n            baseDataValidator.reset().parameter(descriptionParamName).value(description).notBlank().notExceedingLengthOf(500);\n        }\n\n        if (fromApiJsonHelper.parameterExists(currencyCodeParamName, element)) {\n            final String currencyCode = fromApiJsonHelper.extractStringNamed(currencyCodeParamName, element);\n            baseDataValidator.reset().parameter(currencyCodeParamName).value(currencyCode).notBlank();\n        }\n\n        if (fromApiJsonHelper.parameterExists(digitsAfterDecimalParamName, element)) {\n            final Integer digitsAfterDecimal = fromApiJsonHelper.extractIntegerSansLocaleNamed(digitsAfterDecimalParamName, element);\n            baseDataValidator.reset().parameter(digitsAfterDecimalParamName).value(digitsAfterDecimal).notNull().inMinMaxRange(0, 6);\n        }\n\n        if (fromApiJsonHelper.parameterExists(inMultiplesOfParamName, element)) {\n            final Integer inMultiplesOf = fromApiJsonHelper.extractIntegerNamed(inMultiplesOfParamName, element, Locale.getDefault());\n            baseDataValidator.reset().parameter(inMultiplesOfParamName).value(inMultiplesOf).ignoreIfNull().integerZeroOrGreater();\n        }\n\n        if (fromApiJsonHelper.parameterExists(nominalAnnualInterestRateParamName, element)) {\n            final BigDecimal interestRate = fromApiJsonHelper.extractBigDecimalWithLocaleNamed(nominalAnnualInterestRateParamName, element);\n            baseDataValidator.reset().parameter(nominalAnnualInterestRateParamName).value(interestRate).notNull().zeroOrPositiveAmount();\n        }\n\n        if (fromApiJsonHelper.parameterExists(interestCompoundingPeriodTypeParamName, element)) {\n            final Integer interestCompoundingPeriodType = fromApiJsonHelper.extractIntegerSansLocaleNamed(\n                    interestCompoundingPeriodTypeParamName, element);\n            baseDataValidator.reset().parameter(interestCompoundingPeriodTypeParamName).value(interestCompoundingPeriodType).notNull()\n                    .isOneOfTheseValues(SavingsCompoundingInterestPeriodType.integerValues());\n        }\n\n        if (fromApiJsonHelper.parameterExists(interestCalculationTypeParamName, element)) {\n            final Integer interestCalculationType = fromApiJsonHelper.extractIntegerSansLocaleNamed(interestCalculationTypeParamName,\n                    element);\n            baseDataValidator.reset().parameter(interestCalculationTypeParamName).value(interestCalculationType).notNull()\n                    .inMinMaxRange(1, 2);\n        }\n\n        if (fromApiJsonHelper.parameterExists(interestCalculationDaysInYearTypeParamName, element)) {\n            final Integer interestCalculationDaysInYearType = fromApiJsonHelper.extractIntegerSansLocaleNamed(\n                    interestCalculationDaysInYearTypeParamName, element);\n            baseDataValidator.reset().parameter(interestCalculationDaysInYearTypeParamName).value(interestCalculationDaysInYearType)\n                    .notNull().isOneOfTheseValues(360, 365);\n        }\n\n        if (fromApiJsonHelper.parameterExists(minRequiredOpeningBalanceParamName, element)) {\n            final BigDecimal minOpeningBalance = fromApiJsonHelper.extractBigDecimalWithLocaleNamed(minRequiredOpeningBalanceParamName,\n                    element);\n            baseDataValidator.reset().parameter(minRequiredOpeningBalanceParamName).value(minOpeningBalance).ignoreIfNull()\n                    .zeroOrPositiveAmount();\n        }\n\n        if (fromApiJsonHelper.parameterExists(lockinPeriodFrequencyParamName, element)) {\n            final Integer lockinPeriodFrequency = fromApiJsonHelper.extractIntegerWithLocaleNamed(lockinPeriodFrequencyParamName, element);\n            baseDataValidator.reset().parameter(lockinPeriodFrequencyParamName).value(lockinPeriodFrequency).ignoreIfNull()\n                    .integerZeroOrGreater();\n        }\n\n        if (fromApiJsonHelper.parameterExists(lockinPeriodFrequencyTypeParamName, element)) {\n            final Integer lockinPeriodFrequencyType = fromApiJsonHelper.extractIntegerSansLocaleNamed(lockinPeriodFrequencyTypeParamName,\n                    element);\n            baseDataValidator.reset().parameter(lockinPeriodFrequencyTypeParamName).value(lockinPeriodFrequencyType).inMinMaxRange(0, 3);\n        }\n\n        if (fromApiJsonHelper.parameterExists(withdrawalFeeForTransfersParamName, element)) {\n            final Boolean isWithdrawalFeeApplicableForTransfers = fromApiJsonHelper.extractBooleanNamed(withdrawalFeeForTransfersParamName,\n                    element);\n            baseDataValidator.reset().parameter(withdrawalFeeForTransfersParamName).value(isWithdrawalFeeApplicableForTransfers)\n                    .ignoreIfNull().validateForBooleanValue();\n        }\n\n        if (fromApiJsonHelper.parameterExists(feeAmountParamName, element)) {\n            final BigDecimal annualFeeAmount = fromApiJsonHelper.extractBigDecimalWithLocaleNamed(feeAmountParamName, element);\n            baseDataValidator.reset().parameter(feeAmountParamName).value(annualFeeAmount).ignoreIfNull().zeroOrPositiveAmount();\n        }\n\n        if (fromApiJsonHelper.parameterExists(feeOnMonthDayParamName, element)) {\n            final MonthDay monthDayOfAnnualFee = fromApiJsonHelper.extractMonthDayNamed(feeOnMonthDayParamName, element);\n            baseDataValidator.reset().parameter(feeOnMonthDayParamName).value(monthDayOfAnnualFee).ignoreIfNull();\n        }\n\n        if (this.fromApiJsonHelper.parameterExists(minBalanceForInterestCalculationParamName, element)) {\n            final BigDecimal minBalanceForInterestCalculation = this.fromApiJsonHelper.extractBigDecimalWithLocaleNamed(\n                    minBalanceForInterestCalculationParamName, element);\n            baseDataValidator.reset().parameter(minBalanceForInterestCalculationParamName).value(minBalanceForInterestCalculation)\n                    .ignoreIfNull().zeroOrPositiveAmount();\n        }\n\n        final Long savingsControlAccountId = fromApiJsonHelper.extractLongNamed(\n                SAVINGS_PRODUCT_ACCOUNTING_PARAMS.SAVINGS_CONTROL.getValue(), element);\n        baseDataValidator.reset().parameter(SAVINGS_PRODUCT_ACCOUNTING_PARAMS.SAVINGS_CONTROL.getValue()).value(savingsControlAccountId)\n                .ignoreIfNull().integerGreaterThanZero();\n\n        final Long savingsReferenceAccountId = fromApiJsonHelper.extractLongNamed(\n                SAVINGS_PRODUCT_ACCOUNTING_PARAMS.SAVINGS_REFERENCE.getValue(), element);\n        baseDataValidator.reset().parameter(SAVINGS_PRODUCT_ACCOUNTING_PARAMS.SAVINGS_REFERENCE.getValue())\n                .value(savingsReferenceAccountId).ignoreIfNull().integerGreaterThanZero();\n\n        final Long transfersInSuspenseAccountId = fromApiJsonHelper.extractLongNamed(\n                SAVINGS_PRODUCT_ACCOUNTING_PARAMS.TRANSFERS_SUSPENSE.getValue(), element);\n        baseDataValidator.reset().parameter(SAVINGS_PRODUCT_ACCOUNTING_PARAMS.TRANSFERS_SUSPENSE.getValue())\n                .value(transfersInSuspenseAccountId).ignoreIfNull().integerGreaterThanZero();\n\n        final Long interestOnSavingsAccountId = fromApiJsonHelper.extractLongNamed(\n                SAVINGS_PRODUCT_ACCOUNTING_PARAMS.INTEREST_ON_SAVINGS.getValue(), element);\n        baseDataValidator.reset().parameter(SAVINGS_PRODUCT_ACCOUNTING_PARAMS.INTEREST_ON_SAVINGS.getValue())\n                .value(interestOnSavingsAccountId).ignoreIfNull().integerGreaterThanZero();\n\n        final Long incomeFromFeeId = fromApiJsonHelper.extractLongNamed(SAVINGS_PRODUCT_ACCOUNTING_PARAMS.INCOME_FROM_FEES.getValue(),\n                element);\n        baseDataValidator.reset().parameter(SAVINGS_PRODUCT_ACCOUNTING_PARAMS.INCOME_FROM_FEES.getValue()).value(incomeFromFeeId)\n                .ignoreIfNull().integerGreaterThanZero();\n\n        final Long incomeFromPenaltyId = fromApiJsonHelper.extractLongNamed(\n                SAVINGS_PRODUCT_ACCOUNTING_PARAMS.INCOME_FROM_PENALTIES.getValue(), element);\n        baseDataValidator.reset().parameter(SAVINGS_PRODUCT_ACCOUNTING_PARAMS.INCOME_FROM_PENALTIES.getValue()).value(incomeFromPenaltyId)\n                .ignoreIfNull().integerGreaterThanZero();\n\n        validatePaymentChannelFundSourceMappings(fromApiJsonHelper, baseDataValidator, element);\n        validateChargeToIncomeAccountMappings(fromApiJsonHelper, baseDataValidator, element);\n        validateTaxWithHoldingParams(baseDataValidator, element, false);\n    }"}, {"id": "14852", "smell": "feature envy", "severity": "none", "type": "function", "snippet": "\tprivate static void countCompiledInstructions(ProgramBlock pb, ExplainCounts counts, boolean MR, boolean CP, boolean SP) \n\t{\n\t\tif (pb instanceof WhileProgramBlock)\n\t\t{\n\t\t\tWhileProgramBlock tmp = (WhileProgramBlock)pb;\n\t\t\tcountCompiledInstructions(tmp.getPredicate(), counts, MR, CP, SP);\n\t\t\tfor (ProgramBlock pb2 : tmp.getChildBlocks())\n\t\t\t\tcountCompiledInstructions(pb2, counts, MR, CP, SP);\n\t\t}\n\t\telse if (pb instanceof IfProgramBlock)\n\t\t{\n\t\t\tIfProgramBlock tmp = (IfProgramBlock)pb;\t\n\t\t\tcountCompiledInstructions(tmp.getPredicate(), counts, MR, CP, SP);\n\t\t\tfor( ProgramBlock pb2 : tmp.getChildBlocksIfBody() )\n\t\t\t\tcountCompiledInstructions(pb2, counts, MR, CP, SP);\n\t\t\tfor( ProgramBlock pb2 : tmp.getChildBlocksElseBody() )\n\t\t\t\tcountCompiledInstructions(pb2, counts, MR, CP, SP);\n\t\t}\n\t\telse if (pb instanceof ForProgramBlock) //includes ParFORProgramBlock\n\t\t{ \n\t\t\tForProgramBlock tmp = (ForProgramBlock)pb;\t\n\t\t\tcountCompiledInstructions(tmp.getFromInstructions(), counts, MR, CP, SP);\n\t\t\tcountCompiledInstructions(tmp.getToInstructions(), counts, MR, CP, SP);\n\t\t\tcountCompiledInstructions(tmp.getIncrementInstructions(), counts, MR, CP, SP);\n\t\t\tfor( ProgramBlock pb2 : tmp.getChildBlocks() )\n\t\t\t\tcountCompiledInstructions(pb2, counts, MR, CP, SP);\n\t\t\t//additional parfor jobs counted during runtime\n\t\t}\t\t\n\t\telse if (  pb instanceof FunctionProgramBlock ) //includes ExternalFunctionProgramBlock and ExternalFunctionProgramBlockCP\n\t\t{\n\t\t\tFunctionProgramBlock fpb = (FunctionProgramBlock)pb;\n\t\t\tfor( ProgramBlock pb2 : fpb.getChildBlocks() )\n\t\t\t\tcountCompiledInstructions(pb2, counts, MR, CP, SP);\n\t\t}\n\t\telse \n\t\t{\n\t\t\tcountCompiledInstructions(pb.getInstructions(), counts, MR, CP, SP);\n\t\t}\n\t}"}, {"id": "14876", "smell": "data class", "severity": "major", "type": "class", "snippet": "class Segment {\n    private byte segmentType;\n\n    Segment(byte segmentType) {\n        this.segmentType = segmentType;\n    }\n\n    /**\n     * Returns the segmentType value.\n     * \n     * @return byte segmentType value.\n     */\n    public byte getSegmentType() {\n        return segmentType;\n    }\n}"}, {"id": "14893", "smell": "long method", "severity": "none", "type": "function", "snippet": "    private static void emitStackMove(CompilationResultBuilder crb, AArch64MacroAssembler masm, AllocatableValue result, Value input) {\n        try (ScratchRegister r1 = masm.getScratchRegister()) {\n            try (ScratchRegister r2 = masm.getScratchRegister()) {\n                Register rscratch1 = r1.getRegister();\n                Register rscratch2 = r2.getRegister();\n                // use the slot kind to define the operand size\n                PlatformKind kind = input.getPlatformKind();\n                final int size = kind.getSizeInBytes() * Byte.SIZE;\n\n                // Always perform stack -> stack copies through integer registers\n                crb.blockComment(\"[stack -> stack copy]\");\n                AArch64Address src = loadStackSlotAddress(crb, masm, asStackSlot(input), rscratch2);\n                masm.ldr(size, rscratch1, src);\n                AArch64Address dst = loadStackSlotAddress(crb, masm, asStackSlot(result), rscratch2);\n                masm.str(size, rscratch1, dst);\n            }\n        }\n    }"}, {"id": "14902", "smell": "long method", "severity": "major", "type": "function", "snippet": "    @Override\n    public java.util.concurrent.Future<GenerateAutonomousDatabaseWalletResponse>\n            generateAutonomousDatabaseWallet(\n                    final GenerateAutonomousDatabaseWalletRequest request,\n                    final com.oracle.bmc.responses.AsyncHandler<\n                                    GenerateAutonomousDatabaseWalletRequest,\n                                    GenerateAutonomousDatabaseWalletResponse>\n                            handler) {\n        LOG.trace(\"Called async generateAutonomousDatabaseWallet\");\n        final GenerateAutonomousDatabaseWalletRequest interceptedRequest =\n                GenerateAutonomousDatabaseWalletConverter.interceptRequest(request);\n        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =\n                GenerateAutonomousDatabaseWalletConverter.fromRequest(client, interceptedRequest);\n        final com.google.common.base.Function<\n                        javax.ws.rs.core.Response, GenerateAutonomousDatabaseWalletResponse>\n                transformer = GenerateAutonomousDatabaseWalletConverter.fromResponse();\n\n        com.oracle.bmc.responses.AsyncHandler<\n                        GenerateAutonomousDatabaseWalletRequest,\n                        GenerateAutonomousDatabaseWalletResponse>\n                handlerToUse = handler;\n        if (handler != null\n                && this.authenticationDetailsProvider\n                        instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {\n            handlerToUse =\n                    new com.oracle.bmc.util.internal.RefreshAuthTokenWrappingAsyncHandler<\n                            GenerateAutonomousDatabaseWalletRequest,\n                            GenerateAutonomousDatabaseWalletResponse>(\n                            (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)\n                                    this.authenticationDetailsProvider,\n                            handler) {\n                        @Override\n                        public void retryCall() {\n                            final com.oracle.bmc.util.internal.Consumer<javax.ws.rs.core.Response>\n                                    onSuccess =\n                                            new com.oracle.bmc.http.internal.SuccessConsumer<>(\n                                                    this, transformer, interceptedRequest);\n                            final com.oracle.bmc.util.internal.Consumer<Throwable> onError =\n                                    new com.oracle.bmc.http.internal.ErrorConsumer<>(\n                                            this, interceptedRequest);\n                            client.post(\n                                    ib,\n                                    interceptedRequest.getGenerateAutonomousDatabaseWalletDetails(),\n                                    interceptedRequest,\n                                    onSuccess,\n                                    onError);\n                        }\n                    };\n        }\n\n        final com.oracle.bmc.util.internal.Consumer<javax.ws.rs.core.Response> onSuccess =\n                (handler == null)\n                        ? null\n                        : new com.oracle.bmc.http.internal.SuccessConsumer<>(\n                                handlerToUse, transformer, interceptedRequest);\n        final com.oracle.bmc.util.internal.Consumer<Throwable> onError =\n                (handler == null)\n                        ? null\n                        : new com.oracle.bmc.http.internal.ErrorConsumer<>(\n                                handlerToUse, interceptedRequest);\n\n        java.util.concurrent.Future<javax.ws.rs.core.Response> responseFuture =\n                client.post(\n                        ib,\n                        interceptedRequest.getGenerateAutonomousDatabaseWalletDetails(),\n                        interceptedRequest,\n                        onSuccess,\n                        onError);\n\n        if (this.authenticationDetailsProvider\n                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {\n            return new com.oracle.bmc.util.internal.RefreshAuthTokenTransformingFuture<\n                    javax.ws.rs.core.Response, GenerateAutonomousDatabaseWalletResponse>(\n                    responseFuture,\n                    transformer,\n                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)\n                            this.authenticationDetailsProvider,\n                    new com.google.common.base.Supplier<\n                            java.util.concurrent.Future<javax.ws.rs.core.Response>>() {\n                        @Override\n                        public java.util.concurrent.Future<javax.ws.rs.core.Response> get() {\n                            return client.post(\n                                    ib,\n                                    interceptedRequest.getGenerateAutonomousDatabaseWalletDetails(),\n                                    interceptedRequest,\n                                    onSuccess,\n                                    onError);\n                        }\n                    });\n        } else {\n            return new com.oracle.bmc.util.internal.TransformingFuture<>(\n                    responseFuture, transformer);\n        }\n    }"}, {"id": "14956", "smell": "long method", "severity": "minor", "type": "function", "snippet": "\tpublic static Control createCustomAreaWithLink(final Composite parent, final Dialog dialog, final Binary binary) {\n\t\tfinal String binaryLabel = binary.getLabel();\n\t\tfinal String prefix = \"The requested operation cannot be performed due to invalid '\" + binaryLabel\n\t\t\t\t+ \"' settings. Check your '\" + binaryLabel\n\t\t\t\t+ \"' configuration and preferences under the corresponding \";\n\t\tfinal String link = \"preference page\";\n\t\tfinal String suffix = \".\";\n\t\tfinal String text = prefix + link + suffix;\n\n\t\tfinal Composite control = new Composite(parent, NONE);\n\t\tcontrol.setLayout(GridLayoutFactory.fillDefaults().create());\n\t\tfinal GridData gridData = GridDataFactory.fillDefaults().align(LEFT, TOP).grab(true, true).create();\n\t\tcontrol.setLayoutData(gridData);\n\n\t\tfinal StyleRange style = new StyleRange();\n\t\tstyle.underline = true;\n\t\tstyle.underlineStyle = UNDERLINE_LINK;\n\n\t\tfinal StyledText styledText = new StyledText(control, MULTI | READ_ONLY | WRAP);\n\t\tstyledText.setWordWrap(true);\n\t\tstyledText.setJustify(true);\n\t\tstyledText.setText(text);\n\t\tfinal GridData textGridData = GridDataFactory.fillDefaults().align(FILL, FILL).grab(true, true).create();\n\t\ttextGridData.widthHint = TEXT_WIDTH_HINT;\n\t\ttextGridData.heightHint = TEXT_HEIGHT_HINT;\n\t\tstyledText.setLayoutData(textGridData);\n\n\t\tstyledText.setEditable(false);\n\t\tstyledText.setBackground(UIUtils.getSystemColor(COLOR_WIDGET_BACKGROUND));\n\t\tfinal int[] ranges = { text.indexOf(link), link.length() };\n\t\tfinal StyleRange[] styles = { style };\n\t\tstyledText.setStyleRanges(ranges, styles);\n\n\t\tstyledText.addMouseListener(new MouseAdapter() {\n\n\t\t\t@Override\n\t\t\tpublic void mouseDown(final MouseEvent event) {\n\t\t\t\ttry {\n\t\t\t\t\tfinal int offset = styledText.getOffsetAtPoint(new Point(event.x, event.y));\n\t\t\t\t\tfinal StyleRange actualStyle = offset >= 0 ? styledText.getStyleRangeAtOffset(offset) : null;\n\t\t\t\t\tif (null != actualStyle && actualStyle.underline\n\t\t\t\t\t\t\t&& UNDERLINE_LINK == actualStyle.underlineStyle) {\n\n\t\t\t\t\t\tdialog.close();\n\t\t\t\t\t\tfinal PreferenceDialog preferenceDialog = createPreferenceDialogOn(\n\t\t\t\t\t\t\t\tUIUtils.getShell(),\n\t\t\t\t\t\t\t\tBinariesPreferencePage.ID,\n\t\t\t\t\t\t\t\tFILTER_IDS,\n\t\t\t\t\t\t\t\tnull);\n\n\t\t\t\t\t\tif (null != preferenceDialog) {\n\t\t\t\t\t\t\tpreferenceDialog.open();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t} catch (final IllegalArgumentException e) {\n\t\t\t\t\t// We are not over the actual text.\n\t\t\t\t}\n\t\t\t}\n\n\t\t});\n\n\t\treturn control;\n\t}"}, {"id": "14989", "smell": "blob", "severity": "critical", "type": "class", "snippet": "public class GangliaServer implements MonitorService {\n  /*\n   * The Ganglia protocol specific stuff: the xdr_* methods\n   * and the sendToGanglia* methods have been shamelessly ripped off\n   * from Hadoop. All hail the yellow elephant!\n   */\n\n  private static final Logger logger =\n          LoggerFactory.getLogger(GangliaServer.class);\n  public static final int BUFFER_SIZE = 1500; // as per libgmond.c\n  protected byte[] buffer = new byte[BUFFER_SIZE];\n  protected int offset;\n  private final List<SocketAddress> addresses = new ArrayList<SocketAddress>();\n  private DatagramSocket socket = null;\n  private ScheduledExecutorService service =\n          Executors.newSingleThreadScheduledExecutor();\n  private List<HostInfo> hosts;\n  protected final GangliaCollector collectorRunnable;\n  private int pollFrequency = 60;\n  public static final String DEFAULT_UNITS = \"\";\n  public static final int DEFAULT_TMAX = 60;\n  public static final int DEFAULT_DMAX = 0;\n  public static final int DEFAULT_SLOPE = 3;\n  public static final String GANGLIA_DOUBLE_TYPE = \"double\";\n  private volatile boolean isGanglia3 = false;\n  private String hostname;\n  public final String CONF_POLL_FREQUENCY = \"pollFrequency\";\n  public final int DEFAULT_POLL_FREQUENCY = 60;\n  public final String CONF_HOSTS = \"hosts\";\n  public final String CONF_ISGANGLIA3 = \"isGanglia3\";\n  private static final String GANGLIA_CONTEXT = \"flume.\";\n\n  public GangliaServer() throws FlumeException {\n    collectorRunnable = new GangliaCollector();\n  }\n\n  /**\n   * Puts a string into the buffer by first writing the size of the string as an\n   * int, followed by the bytes of the string, padded if necessary to a multiple\n   * of 4.\n   *\n   * @param s the string to be written to buffer at offset location\n   */\n  protected void xdr_string(String s) {\n    byte[] bytes = s.getBytes();\n    int len = bytes.length;\n    xdr_int(len);\n    System.arraycopy(bytes, 0, buffer, offset, len);\n    offset += len;\n    pad();\n  }\n\n  /**\n   * Pads the buffer with zero bytes up to the nearest multiple of 4.\n   */\n  private void pad() {\n    int newOffset = ((offset + 3) / 4) * 4;\n    while (offset < newOffset) {\n      buffer[offset++] = 0;\n    }\n  }\n\n  /**\n   * Puts an integer into the buffer as 4 bytes, big-endian.\n   */\n  protected void xdr_int(int i) {\n    buffer[offset++] = (byte) ((i >> 24) & 0xff);\n    buffer[offset++] = (byte) ((i >> 16) & 0xff);\n    buffer[offset++] = (byte) ((i >> 8) & 0xff);\n    buffer[offset++] = (byte) (i & 0xff);\n  }\n\n  public synchronized void sendToGangliaNodes() {\n    DatagramPacket packet;\n    for (SocketAddress addr : addresses) {\n      try {\n        packet = new DatagramPacket(buffer, offset, addr);\n        socket.send(packet);\n      } catch (Exception ex) {\n        logger.warn(\"Could not send metrics to metrics server: \"\n                + addr.toString(), ex);\n      }\n    }\n    offset = 0;\n  }\n\n  /**\n   * Start this server, causing it to poll JMX at the configured frequency.\n   */\n  @Override\n  public void start() {\n    try {\n      socket = new DatagramSocket();\n      hostname = InetAddress.getLocalHost().getHostName();\n    } catch (SocketException ex) {\n      logger.error(\"Could not create socket for metrics collection.\");\n      throw new FlumeException(\n              \"Could not create socket for metrics collection.\", ex);\n    } catch (Exception ex2) {\n      logger.warn(\"Unknown error occured\", ex2);\n    }\n    for (HostInfo host : hosts) {\n      addresses.add(new InetSocketAddress(\n              host.getHostName(), host.getPortNumber()));\n    }\n    collectorRunnable.server = this;\n    if (service.isShutdown() || service.isTerminated()) {\n      service = Executors.newSingleThreadScheduledExecutor();\n    }\n    service.scheduleWithFixedDelay(collectorRunnable, 0,\n            pollFrequency, TimeUnit.SECONDS);\n  }\n\n  /**\n   * Stop this server.\n   */\n  @Override\n  public void stop() {\n    service.shutdown();\n\n    while (!service.isTerminated()) {\n      try {\n        logger.warn(\"Waiting for ganglia service to stop\");\n        service.awaitTermination(500, TimeUnit.MILLISECONDS);\n      } catch (InterruptedException ex) {\n        logger.warn(\"Interrupted while waiting\"\n                + \" for ganglia monitor to shutdown\", ex);\n        service.shutdownNow();\n      }\n    }\n    addresses.clear();\n  }\n\n  /**\n   *\n   * @param pollFrequency Seconds between consecutive JMX polls.\n   */\n  public void setPollFrequency(int pollFrequency) {\n    this.pollFrequency = pollFrequency;\n  }\n\n  /**\n   *\n   * @return Seconds between consecutive JMX polls\n   */\n  public int getPollFrequency() {\n    return pollFrequency;\n  }\n\n  /**\n   *\n   * @param isGanglia3 When true, ganglia 3 messages will be sent, else Ganglia\n   * 3.1 formatted messages are sent.\n   */\n  public void setIsGanglia3(boolean isGanglia3) {\n    this.isGanglia3 = isGanglia3;\n  }\n\n  /**\n   *\n   * @return True if the server is currently sending ganglia 3 formatted msgs.\n   * False if the server returns Ganglia 3.1\n   */\n  public boolean isGanglia3() {\n    return this.isGanglia3;\n  }\n\n  protected void createGangliaMessage(String name, String value) {\n    logger.debug(\"Sending ganglia3 formatted message.\"\n            + name + \": \" + value);\n    name = hostname + \".\" + name;\n    xdr_int(0);\n    String type = \"string\";\n    try {\n      Float.parseFloat(value);\n      type = \"float\";\n    } catch (NumberFormatException ex) {\n      // The param is a string, and so leave the type as is.\n    }\n    xdr_string(type); // metric type\n    xdr_string(name);\n    xdr_string(value);\n    xdr_string(DEFAULT_UNITS);\n    xdr_int(DEFAULT_SLOPE);\n    xdr_int(DEFAULT_TMAX);\n    xdr_int(DEFAULT_DMAX);\n  }\n\n  protected void createGangliaMessage31(String name, String value) {\n    logger.debug(\"Sending ganglia 3.1 formatted message: \"\n            + name + \": \" + value);\n    xdr_int(128); // metric_id = metadata_msg\n    xdr_string(hostname); // hostname\n    xdr_string(name); // metric name\n    xdr_int(0); // spoof = False\n    String type = \"string\";\n    try {\n      Float.parseFloat(value);\n      type = \"float\";\n    } catch (NumberFormatException ex) {\n      // The param is a string, and so leave the type as is.\n    }\n    xdr_string(type); // metric type\n    xdr_string(name); // metric name\n    xdr_string(DEFAULT_UNITS); // units\n    xdr_int(DEFAULT_SLOPE); // slope\n    xdr_int(DEFAULT_TMAX); // tmax, the maximum time between metrics\n    xdr_int(DEFAULT_DMAX); // dmax, the maximum data value\n    xdr_int(1); /*Num of the entries in extra_value field for Ganglia 3.1.x*/\n    xdr_string(\"GROUP\"); /*Group attribute*/\n    xdr_string(\"flume\"); /*Group value*/\n\n    this.sendToGangliaNodes();\n\n    // Now we send out a message with the actual value.\n    // Technically, we only need to send out the metadata message once for\n    // each metric, but I don't want to have to record which metrics we did and\n    // did not send.\n    xdr_int(133); // we are sending a string value\n    xdr_string(hostname); // hostName\n    xdr_string(name); // metric name\n    xdr_int(0); // spoof = False\n    xdr_string(\"%s\"); // format field\n    xdr_string(value); // metric value\n  }\n\n  @Override\n  public void configure(Context context) {\n    this.pollFrequency = context.getInteger(this.CONF_POLL_FREQUENCY, 60);\n    String localHosts = context.getString(this.CONF_HOSTS);\n    if (localHosts == null || localHosts.isEmpty()) {\n      throw new ConfigurationException(\"Hosts list cannot be empty.\");\n    }\n    this.hosts = this.getHostsFromString(localHosts);\n    this.isGanglia3 = context.getBoolean(this.CONF_ISGANGLIA3, false);\n  }\n\n  private List<HostInfo> getHostsFromString(String hosts)\n          throws FlumeException {\n    List<HostInfo> hostInfoList = new ArrayList<HostInfo>();\n    String[] hostsAndPorts = hosts.split(\",\");\n    int i = 0;\n    for (String host : hostsAndPorts) {\n      String[] hostAndPort = host.split(\":\");\n      if (hostAndPort.length < 2) {\n        logger.warn(\"Invalid ganglia host: \", host);\n        continue;\n      }\n      try {\n        hostInfoList.add(new HostInfo(\"ganglia_host-\" + String.valueOf(i),\n                hostAndPort[0], Integer.parseInt(hostAndPort[1])));\n      } catch (Exception e) {\n        logger.warn(\"Invalid ganglia host: \" + host, e);\n        continue;\n      }\n    }\n    if (hostInfoList.isEmpty()) {\n      throw new FlumeException(\"No valid ganglia hosts defined!\");\n    }\n    return hostInfoList;\n  }\n\n  /**\n   * Worker which polls JMX for all mbeans with\n   * {@link javax.management.ObjectName} within the flume namespace:\n   * org.apache.flume. All attributes of such beans are sent to the all hosts\n   * specified by the server that owns it's instance.\n   *\n   */\n  protected class GangliaCollector implements Runnable {\n\n    private GangliaServer server;\n\n    @Override\n    public void run() {\n      try {\n        Map<String, Map<String, String>> metricsMap =\n                JMXPollUtil.getAllMBeans();\n        for (String component : metricsMap.keySet()) {\n          Map<String, String> attributeMap = metricsMap.get(component);\n          for (String attribute : attributeMap.keySet()) {\n            if (isGanglia3) {\n              server.createGangliaMessage(GANGLIA_CONTEXT + component + \".\"\n                      + attribute,\n                      attributeMap.get(attribute));\n            } else {\n              server.createGangliaMessage31(GANGLIA_CONTEXT + component + \".\"\n                      + attribute,\n                      attributeMap.get(attribute));\n            }\n            server.sendToGangliaNodes();\n          }\n        }\n      } catch (Throwable t) {\n        logger.error(\"Unexpected error\", t);\n      }\n    }\n  }\n}"}, {"id": "15029", "smell": "feature envy", "severity": "major", "type": "function", "snippet": "    private static List<NameValuePair> getUserDetails(String query) {\n        List<NameValuePair> details = new ArrayList<NameValuePair>();\n        if (query != null && !query.isEmpty()) {\n            StringTokenizer allParams = new StringTokenizer(query, \"&\");\n            while (allParams.hasMoreTokens()) {\n                String param = allParams.nextToken();\n                details.add(new BasicNameValuePair(param.substring(0, param.indexOf(\"=\")),\n                        param.substring(param.indexOf(\"=\") + 1)));\n            }\n        }\n\n        return details;\n    }"}, {"id": "15170", "smell": "data class", "severity": "critical", "type": "class", "snippet": "public class Shape {\n\n    private String type;\n\n    private Map<String, Member> members = Collections.emptyMap();\n\n    private String documentation;\n\n    private List<String> required;\n\n    private List<String> enumValues;\n\n    private String payload;\n\n    private boolean flattened;\n\n    private boolean exception;\n\n    private boolean streaming;\n\n    private boolean wrapper;\n\n    private Member listMember;\n\n    private Member mapKeyType;\n\n    private Member mapValueType;\n\n    @JsonProperty(value = \"error\")\n    private ErrorTrait errorTrait;\n\n    private long min;\n\n    private long max;\n\n    private String pattern;\n\n    private boolean fault;\n\n    private boolean deprecated;\n\n    @JsonProperty(value = \"eventstream\")\n    private boolean isEventStream;\n\n    @JsonProperty(value = \"event\")\n    private boolean isEvent;\n\n    private String timestampFormat;\n\n    private boolean sensitive;\n\n    public boolean isFault() {\n        return fault;\n    }\n\n    public void setFault(boolean fault) {\n        this.fault = fault;\n    }\n\n    public String getPattern() {\n        return pattern;\n    }\n\n    public void setPattern(String pattern) {\n        this.pattern = pattern;\n    }\n\n    public String getType() {\n        return type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public Map<String, Member> getMembers() {\n        return members;\n    }\n\n    public void setMembers(Map<String, Member> members) {\n        this.members = members;\n    }\n\n    public String getDocumentation() {\n        return documentation;\n    }\n\n    public void setDocumentation(String documentation) {\n        this.documentation = documentation;\n    }\n\n    public List<String> getRequired() {\n        return required;\n    }\n\n    public void setRequired(List<String> required) {\n        this.required = required;\n    }\n\n    public List<String> getEnumValues() {\n        return enumValues;\n    }\n\n    @JsonProperty(value = \"enum\")\n    public void setEnumValues(List<String> enumValues) {\n        this.enumValues = enumValues;\n    }\n\n    public String getPayload() {\n        return payload;\n    }\n\n    public void setPayload(String payload) {\n        this.payload = payload;\n    }\n\n    public boolean isFlattened() {\n        return flattened;\n    }\n\n    public void setFlattened(boolean flattened) {\n        this.flattened = flattened;\n    }\n\n    public boolean isException() {\n        return exception;\n    }\n\n    public void setException(boolean exception) {\n        this.exception = exception;\n    }\n\n    public Member getMapKeyType() {\n        return mapKeyType;\n    }\n\n    @JsonProperty(value = \"key\")\n    public void setMapKeyType(Member mapKeyType) {\n        this.mapKeyType = mapKeyType;\n    }\n\n    public Member getMapValueType() {\n        return mapValueType;\n    }\n\n    @JsonProperty(value = \"value\")\n    public void setMapValueType(Member mapValueType) {\n        this.mapValueType = mapValueType;\n    }\n\n    public Member getListMember() {\n        return listMember;\n    }\n\n    @JsonProperty(value = \"member\")\n    public void setListMember(Member listMember) {\n        this.listMember = listMember;\n    }\n\n    public long getMin() {\n        return min;\n    }\n\n    public void setMin(long min) {\n        this.min = min;\n    }\n\n    public long getMax() {\n        return max;\n    }\n\n    public void setMax(long max) {\n        this.max = max;\n    }\n\n    public boolean isStreaming() {\n        return streaming;\n    }\n\n    public void setStreaming(boolean streaming) {\n        this.streaming = streaming;\n    }\n\n    public boolean isWrapper() {\n        return wrapper;\n    }\n\n    public void setWrapper(boolean wrapper) {\n        this.wrapper = wrapper;\n    }\n\n    public ErrorTrait getErrorTrait() {\n        return errorTrait;\n    }\n\n    public void setErrorTrait(ErrorTrait errorTrait) {\n        this.errorTrait = errorTrait;\n    }\n\n    public boolean isDeprecated() {\n        return deprecated;\n    }\n\n    public void setDeprecated(boolean deprecated) {\n        this.deprecated = deprecated;\n    }\n\n    public boolean isEventStream() {\n        return isEventStream;\n    }\n\n    public void setIsEventStream(boolean eventStream) {\n        isEventStream = eventStream;\n    }\n\n    public boolean isEvent() {\n        return isEvent;\n    }\n\n    public void setIsEvent(boolean event) {\n        isEvent = event;\n    }\n\n    public String getTimestampFormat() {\n        return timestampFormat;\n    }\n\n    public void setTimestampFormat(String timestampFormat) {\n        this.timestampFormat = timestampFormat;\n    }\n\n    public boolean isSensitive() {\n        return sensitive;\n    }\n\n    public void setSensitive(boolean sensitive) {\n        this.sensitive = sensitive;\n    }\n}"}, {"id": "15187", "smell": "blob", "severity": "none", "type": "class", "snippet": "final class MachOSymtab {\n\n    /**\n     * ByteBuffer holding the LC_SYMTAB command contents.\n     */\n    private final ByteBuffer symtabCmd;\n\n    private int symtabDataSize;\n\n    private final ArrayList<MachOSymbol> localSymbols = new ArrayList<>();\n    private final ArrayList<MachOSymbol> globalSymbols = new ArrayList<>();\n    private final ArrayList<MachOSymbol> undefSymbols = new ArrayList<>();\n\n    /**\n     * Number of symbols added.\n     */\n    private int symbolCount;\n\n    /**\n     * String holding symbol table strings.\n     */\n    private final StringBuilder strTabContent = new StringBuilder();\n\n    /**\n     * Keeps track of bytes in string table since strTabContent.length() is number of chars, not\n     * bytes.\n     */\n    private int strTabNrOfBytes = 0;\n\n    MachOSymtab() {\n        symtabCmd = MachOByteBuffer.allocate(symtab_command.totalsize);\n\n        symtabCmd.putInt(symtab_command.cmd.off, symtab_command.LC_SYMTAB);\n        symtabCmd.putInt(symtab_command.cmdsize.off, symtab_command.totalsize);\n\n        symbolCount = 0;\n\n    }\n\n    static int getAlign() {\n        return (4);\n    }\n\n    MachOSymbol addSymbolEntry(String name, byte type, byte secHdrIndex, long offset) {\n        // Get the current symbol index and append symbol name to string table.\n        int index;\n        MachOSymbol sym;\n\n        if (name.isEmpty()) {\n            index = 0;\n            strTabContent.append('\\0');\n            strTabNrOfBytes += 1;\n            sym = new MachOSymbol(symbolCount, index, type, secHdrIndex, offset);\n            localSymbols.add(sym);\n        } else {\n            // We can't trust strTabContent.length() since that is\n            // chars (UTF16), keep track of bytes on our own.\n            index = strTabNrOfBytes;\n            strTabContent.append(\"_\").append(name).append('\\0');\n            // + 1 for null, + 1 for \"_\"\n            strTabNrOfBytes += (name.getBytes().length + 1 + 1);\n\n            sym = new MachOSymbol(symbolCount, index, type, secHdrIndex, offset);\n            switch (type) {\n                case nlist_64.N_EXT:\n                    undefSymbols.add(sym);\n                    break;\n                case nlist_64.N_SECT:\n                case nlist_64.N_UNDF:  // null symbol\n                    localSymbols.add(sym);\n                    break;\n                case nlist_64.N_SECT | nlist_64.N_EXT:\n                    globalSymbols.add(sym);\n                    break;\n                default:\n                    System.out.println(\"Unsupported Symbol type \" + type);\n                    break;\n            }\n        }\n        symbolCount++;\n        return (sym);\n    }\n\n    void setOffset(int symoff) {\n        symtabCmd.putInt(symtab_command.symoff.off, symoff);\n    }\n\n    // Update the symbol indexes once all symbols have been added.\n    // This is required since we'll be reordering the symbols in the\n    // file to be in the order of Local, global and Undefined.\n    void updateIndexes() {\n        int index = 0;\n\n        // Update the local symbol indexes\n        for (int i = 0; i < localSymbols.size(); i++) {\n            MachOSymbol sym = localSymbols.get(i);\n            sym.setIndex(index++);\n        }\n\n        // Update the global symbol indexes\n        for (int i = 0; i < globalSymbols.size(); i++) {\n            MachOSymbol sym = globalSymbols.get(i);\n            sym.setIndex(index++);\n        }\n\n        // Update the undefined symbol indexes\n        for (int i = index; i < undefSymbols.size(); i++) {\n            MachOSymbol sym = undefSymbols.get(i);\n            sym.setIndex(index++);\n        }\n    }\n\n    // Update LC_SYMTAB command fields based on the number of symbols added\n    // return the file size taken up by symbol table entries and strings\n    int calcSizes() {\n        int stroff;\n\n        stroff = symtabCmd.getInt(symtab_command.symoff.off) + (nlist_64.totalsize * symbolCount);\n        symtabCmd.putInt(symtab_command.nsyms.off, symbolCount);\n        symtabCmd.putInt(symtab_command.stroff.off, stroff);\n        symtabCmd.putInt(symtab_command.strsize.off, strTabNrOfBytes);\n        symtabDataSize = (nlist_64.totalsize * symbolCount) + strTabNrOfBytes;\n\n        return (symtabDataSize);\n    }\n\n    int getNumLocalSyms() {\n        return localSymbols.size();\n    }\n\n    int getNumGlobalSyms() {\n        return globalSymbols.size();\n    }\n\n    int getNumUndefSyms() {\n        return undefSymbols.size();\n    }\n\n    byte[] getCmdArray() {\n        return symtabCmd.array();\n    }\n\n    // Create a single byte array that contains the symbol table entries\n    // and string table\n    byte[] getDataArray() {\n        ByteBuffer symtabData = MachOByteBuffer.allocate(symtabDataSize);\n        byte[] retarray;\n\n        // Add the local symbols\n        for (int i = 0; i < localSymbols.size(); i++) {\n            MachOSymbol sym = localSymbols.get(i);\n            byte[] arr = sym.getArray();\n            symtabData.put(arr);\n        }\n        // Add the global symbols\n        for (int i = 0; i < globalSymbols.size(); i++) {\n            MachOSymbol sym = globalSymbols.get(i);\n            byte[] arr = sym.getArray();\n            symtabData.put(arr);\n        }\n        // Add the undefined symbols\n        for (int i = 0; i < undefSymbols.size(); i++) {\n            MachOSymbol sym = undefSymbols.get(i);\n            byte[] arr = sym.getArray();\n            symtabData.put(arr);\n        }\n\n        // Add the stringtable\n        byte[] strs = strTabContent.toString().getBytes();\n        symtabData.put(strs);\n\n        retarray = symtabData.array();\n\n        return (retarray);\n    }\n}"}, {"id": "15226", "smell": "feature envy", "severity": "minor", "type": "function", "snippet": "    @Override\n    public RelOptCost getCost(HiveJoin join) {\n      final RelMetadataQuery mq = join.getCluster().getMetadataQuery();\n      // 1. Sum of input cardinalities\n      final Double leftRCount = mq.getRowCount(join.getLeft());\n      final Double rightRCount = mq.getRowCount(join.getRight());\n      if (leftRCount == null || rightRCount == null) {\n        return null;\n      }\n      final double rCount = leftRCount + rightRCount;\n      // 2. CPU cost = HashTable  construction  cost  +\n      //               join cost\n      ImmutableList<Double> cardinalities = new ImmutableList.Builder<Double>().\n              add(leftRCount).\n              add(rightRCount).\n              build();\n      ImmutableBitSet.Builder streamingBuilder = ImmutableBitSet.builder();\n      switch (join.getStreamingSide()) {\n        case LEFT_RELATION:\n          streamingBuilder.set(0);\n          break;\n        case RIGHT_RELATION:\n          streamingBuilder.set(1);\n          break;\n        default:\n          return null;\n      }\n      ImmutableBitSet streaming = streamingBuilder.build();\n      final double cpuCost = algoUtils.computeBucketMapJoinCPUCost(cardinalities, streaming);\n      // 3. IO cost = cost of transferring small tables to join node *\n      //              degree of parallelism\n      final Double leftRAverageSize = mq.getAverageRowSize(join.getLeft());\n      final Double rightRAverageSize = mq.getAverageRowSize(join.getRight());\n      if (leftRAverageSize == null || rightRAverageSize == null) {\n        return null;\n      }\n      ImmutableList<Pair<Double,Double>> relationInfos = new ImmutableList.Builder<Pair<Double,Double>>().\n              add(new Pair<Double,Double>(leftRCount,leftRAverageSize)).\n              add(new Pair<Double,Double>(rightRCount,rightRAverageSize)).\n              build();\n      //TODO: No Of buckets is not same as no of splits\n      JoinAlgorithm oldAlgo = join.getJoinAlgorithm();\n      join.setJoinAlgorithm(TezBucketJoinAlgorithm.INSTANCE);\n      final int parallelism = mq.splitCount(join) == null\n              ? 1 : mq.splitCount(join);\n      join.setJoinAlgorithm(oldAlgo);\n\n      final double ioCost = algoUtils.computeBucketMapJoinIOCost(relationInfos, streaming, parallelism);\n      // 4. Result\n      return HiveCost.FACTORY.makeCost(rCount, cpuCost, ioCost);\n    }"}, {"id": "15309", "smell": "blob", "severity": "minor", "type": "class", "snippet": "@SuppressWarnings(\"unchecked\")\npublic class BoltExecutorStats extends CommonStats {\n    MultiCountStatAndMetric executedStats;\n    MultiLatencyStatAndMetric processLatencyStats;\n    MultiLatencyStatAndMetric executeLatencyStats;\n\n    public BoltExecutorStats(int rate, int numStatBuckets) {\n        super(rate, numStatBuckets);\n        this.executedStats = new MultiCountStatAndMetric(numStatBuckets);\n        this.processLatencyStats = new MultiLatencyStatAndMetric(numStatBuckets);\n        this.executeLatencyStats = new MultiLatencyStatAndMetric(numStatBuckets);\n    }\n\n    public MultiCountStatAndMetric getExecuted() {\n        return executedStats;\n    }\n\n    public MultiLatencyStatAndMetric getProcessLatencies() {\n        return processLatencyStats;\n    }\n\n    public MultiLatencyStatAndMetric getExecuteLatencies() {\n        return executeLatencyStats;\n    }\n\n    @Override\n    public void cleanupStats() {\n        executedStats.close();\n        processLatencyStats.close();\n        executeLatencyStats.close();\n        super.cleanupStats();\n    }\n\n    public void boltExecuteTuple(String component, String stream, long latencyMs) {\n        List key = Lists.newArrayList(component, stream);\n        this.getExecuted().incBy(key, this.rate);\n        this.getExecuteLatencies().record(key, latencyMs);\n    }\n\n    public void boltAckedTuple(String component, String stream, long latencyMs, Counter ackedCounter) {\n        List key = Lists.newArrayList(component, stream);\n        this.getAcked().incBy(key, this.rate);\n        ackedCounter.inc(this.rate);\n        this.getProcessLatencies().record(key, latencyMs);\n    }\n\n    public void boltFailedTuple(String component, String stream, long latencyMs, Counter failedCounter) {\n        List key = Lists.newArrayList(component, stream);\n        this.getFailed().incBy(key, this.rate);\n        failedCounter.inc(this.rate);\n    }\n\n    @Override\n    public ExecutorStats renderStats() {\n        ExecutorStats ret = new ExecutorStats();\n        // common stats\n        ret.set_emitted(valueStat(getEmitted()));\n        ret.set_transferred(valueStat(getTransferred()));\n        ret.set_rate(this.rate);\n\n        // bolt stats\n        BoltStats boltStats = new BoltStats(\n            ClientStatsUtil.windowSetConverter(valueStat(getAcked()), ClientStatsUtil.TO_GSID, ClientStatsUtil.IDENTITY),\n            ClientStatsUtil.windowSetConverter(valueStat(getFailed()), ClientStatsUtil.TO_GSID, ClientStatsUtil.IDENTITY),\n            ClientStatsUtil.windowSetConverter(valueStat(processLatencyStats), ClientStatsUtil.TO_GSID, ClientStatsUtil.IDENTITY),\n            ClientStatsUtil.windowSetConverter(valueStat(executedStats), ClientStatsUtil.TO_GSID, ClientStatsUtil.IDENTITY),\n            ClientStatsUtil.windowSetConverter(valueStat(executeLatencyStats), ClientStatsUtil.TO_GSID, ClientStatsUtil.IDENTITY));\n        ret.set_specific(ExecutorSpecificStats.bolt(boltStats));\n\n        return ret;\n    }\n}"}, {"id": "15311", "smell": "feature envy", "severity": "critical", "type": "function", "snippet": "    @Override\n    public ILSMIndex createInstance(INCServiceContext serviceCtx) throws HyracksDataException {\n        IIOManager ioManager = serviceCtx.getIoManager();\n        FileReference file = ioManager.resolve(path);\n        List<IVirtualBufferCache> virtualBufferCaches = vbcProvider.getVirtualBufferCaches(serviceCtx, file);\n        ioOpCallbackFactory.initialize(serviceCtx, this);\n        return LSMRTreeUtils.createLSMTreeWithAntiMatterTuples(ioManager, virtualBufferCaches, file,\n                storageManager.getBufferCache(serviceCtx), typeTraits, cmpFactories, btreeCmpFactories,\n                valueProviderFactories, rtreePolicyType,\n                mergePolicyFactory.createMergePolicy(mergePolicyProperties, serviceCtx),\n                opTrackerProvider.getOperationTracker(serviceCtx, this), ioSchedulerProvider.getIoScheduler(serviceCtx),\n                ioOpCallbackFactory, linearizeCmpFactory, rtreeFields, filterTypeTraits, filterCmpFactories,\n                filterFields, durable, isPointMBR, metadataPageManagerFactory);\n    }"}, {"id": "15341", "smell": "data class", "severity": "none", "type": "class", "snippet": "public class ServletContextListenerStartup implements ServletContextListener {\n    /** Configuration file path parameter name. */\n    public static final String IGNITE_CFG_FILE_PATH_PARAM = \"IgniteConfigurationFilePath\";\n\n    /** Names of started Ignite instances. */\n    private final Collection<String> igniteInstanceNames = new ArrayList<>();\n\n    /** {@inheritDoc} */\n    @Override public void contextInitialized(ServletContextEvent evt) {\n        ServletContext ctx = evt.getServletContext();\n\n        String cfgFile = ctx.getInitParameter(IGNITE_CFG_FILE_PATH_PARAM);\n\n        Collection<IgniteConfiguration> cfgs;\n        GridSpringResourceContext rsrcCtx = null;\n\n        if (cfgFile != null) {\n            URL cfgUrl = null;\n\n            try {\n                cfgUrl = evt.getServletContext().getResource(\"/META-INF/\" + cfgFile);\n            }\n            catch (MalformedURLException ignored) {\n                // Ignore, we still need to try with IGNITE_HOME.\n            }\n\n            if (cfgUrl == null)\n                // Try with IGNITE_HOME and with context class loader.\n                cfgUrl = U.resolveIgniteUrl(cfgFile);\n\n            if (cfgUrl == null)\n                throw new IgniteException(\"Failed to find Spring configuration file (path provided should be \" +\n                    \"either absolute, relative to IGNITE_HOME, or relative to META-INF folder): \" + cfgFile);\n\n            IgniteBiTuple<Collection<IgniteConfiguration>, ? extends GridSpringResourceContext> t;\n\n            try {\n                t = IgnitionEx.loadConfigurations(cfgUrl);\n            }\n            catch (IgniteCheckedException e) {\n                throw new IgniteException(\"Failed to load Ignite configuration.\", e);\n            }\n\n            cfgs = t.get1();\n            rsrcCtx  = t.get2();\n\n            if (cfgs.isEmpty())\n                throw new IgniteException(\"Can't find grid factory configuration in: \" + cfgUrl);\n        }\n        else\n            cfgs = Collections.<IgniteConfiguration>singleton(new IgniteConfiguration());\n\n        try {\n            assert !cfgs.isEmpty();\n\n            for (IgniteConfiguration cfg : cfgs) {\n                assert cfg != null;\n\n                Ignite ignite;\n\n                synchronized (ServletContextListenerStartup.class) {\n                    try {\n                        ignite = G.ignite(cfg.getIgniteInstanceName());\n                    }\n                    catch (IgniteIllegalStateException ignored) {\n                        ignite = IgnitionEx.start(new IgniteConfiguration(cfg), rsrcCtx);\n                    }\n                }\n\n                // Check if grid is not null - started properly.\n                if (ignite != null)\n                    igniteInstanceNames.add(ignite.name());\n            }\n        }\n        catch (IgniteCheckedException e) {\n            // Stop started grids only.\n            for (String name : igniteInstanceNames)\n                G.stop(name, true);\n\n            throw new IgniteException(\"Failed to start Ignite.\", e);\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override public void contextDestroyed(ServletContextEvent evt) {\n        // Stop started grids only.\n        for (String name: igniteInstanceNames)\n            G.stop(name, true);\n    }\n\n    /** {@inheritDoc} */\n    @Override public String toString() {\n        return S.toString(ServletContextListenerStartup.class, this);\n    }\n}"}]